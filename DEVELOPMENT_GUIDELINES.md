# 开发规范与经验教训

## 📋 目录
- [核心开发原则](#核心开发原则)
- [数据脱敏规范](#数据脱敏规范)
- [配置管理规范](#配置管理规范)
- [测试开发规范](#测试开发规范)
- [代码风格规范](#代码风格规范)
- [经验教训总结](#经验教训总结)
- [反面教材与改进](#反面教材与改进)

---

## 🎯 核心开发原则

### 1. 设计文档至上原则 ⚠️ **最高优先级**
**规则**: 设计文档是需求和最终纲领，代码必须严格按照设计文档实现，绝对不允许为了适应代码而修改设计文档。

**核心要点**:
- 设计文档 = 需求规范 = 开发目标
- 代码必须符合设计文档，而不是相反
- 除非用户明确要求或认可，否则禁止修改设计文档
- 如果代码与设计文档不符，必须修改代码而非文档

**正确做法**:
```
❌ 严重错误: 发现代码实现与设计文档不符时，修改设计文档来适应代码
✅ 正确做法: 发现不符时，修改代码来符合设计文档要求
✅ 正确做法: 如需修改设计文档，必须先征得用户同意
```

### 2. 确认优先原则
**规则**: 当遇到不确定的需求或配置问题时，必须先与用户确认，不得擅自做决定。

**适用场景**:
- 配置文件路径不明确时
- 需要创建新文件或目录时
- 功能需求存在歧义时
- 测试行为需要调整时

**正确做法**:
```
❌ 错误: 为了通过测试，直接创建 config/rename_rules.yaml
✅ 正确: 发现配置路径问题时，停下来询问用户正确的配置方式
```

### 3. 最小影响原则
**规则**: 优先使用现有的文件和配置，避免创建不必要的新文件。

**实施要点**:
- 优先编辑现有文件而非创建新文件
- 使用项目既定的配置路径和结构
- 避免引入额外的复杂性

---

## 🔒 数据脱敏规范

### 1. 脱敏原则与目标
**规则**: 项目中的所有敏感数据必须进行脱敏处理，确保代码可以安全地用于演示、分享和开源。

**脱敏目标**:
- 移除所有真实的域名和网站标识
- 替换敏感的视频编号和标识符
- 清理测试数据中的个人信息
- 确保示例数据的通用性和安全性

### 2. 敏感数据识别标准

#### 域名和网站标识
```bash
# 需要脱敏的模式
*.net、*.com、*.xyz 等真实域名
网站特有的前缀或后缀标识
具有商业性质的标识符
```

#### 视频编号和标识符
```bash
# 需要脱敏的模式
[A-Z]{3,6}-[0-9]{3,4}  # 如: FSDSS896, ADN001, DVMM232
特定行业的编号规则
具有识别性的序列号
```

#### 文件路径和目录名
```bash
# 需要脱敏的内容
包含敏感信息的路径名
具有个人标识的目录结构
真实的存储位置信息
```

### 3. 脱敏实施策略

#### 系统性脱敏流程
1. **全面扫描**: 使用正则表达式扫描所有文件
2. **分类处理**: 区分代码文件、测试文件、配置文件、文档文件
3. **批量替换**: 使用一致的替换规则进行批量处理
4. **验证测试**: 确保脱敏后功能正常
5. **文档更新**: 同步更新相关文档

#### 脱敏替换规则
```yaml
# 域名脱敏规则
真实域名 -> 通用示例域名
btnets.net -> example1.net
kfa55.com -> site1234.com
xxx2222.xyz -> test2222.xyz

# 视频编号脱敏规则
敏感编号 -> 通用测试编号
FSDSS896 -> TEST896
ADN001 -> DEMO001
DVMM232 -> SAMPLE232
```

### 4. 脱敏工具和方法

#### 正则表达式扫描
```bash
# 扫描敏感域名
grep -r "btnets\.net\|kfa55\.com\|xxx2222\.xyz" .

# 扫描敏感视频编号
grep -r "(FSDSS|ADN|DVMM)[0-9]{3}" .

# 扫描特定文件类型
find . -name "*.py" -o -name "*.yaml" -o -name "*.md" | xargs grep "pattern"
```

#### 批量替换工具
```bash
# 使用sed进行批量替换
find . -type f -name "*.py" -exec sed -i 's/btnets\.net/example1.net/g' {} +

# 使用专门的重命名工具
rename 's/btnets\.net/example1.net/' *.mp4
```

### 5. 脱敏验证流程

#### 完整性验证
```bash
# 1. 扫描残留敏感数据
grep -r "敏感关键词" .

# 2. 运行完整测试套件
pytest tests/ -v

# 3. 验证功能正常
python -m tools.filename_formatter --help
```

#### 测试数据验证
- 确保测试用例使用通用数据
- 验证示例输出不包含敏感信息
- 检查文档中的示例代码

### 6. 脱敏维护策略

#### 持续监控
- 新增代码时检查敏感数据
- 定期进行全项目扫描
- 建立敏感词汇表和检查清单

#### 团队协作
- 代码审查时关注脱敏要求
- 提供脱敏工具和脚本
- 培训团队成员脱敏意识

### 7. 脱敏检查清单

#### 开发阶段检查
- [ ] 新增的测试数据是否使用通用示例？
- [ ] 配置文件中是否包含敏感信息？
- [ ] 示例代码是否使用了真实数据？
- [ ] 文档中的截图是否包含敏感内容？

#### 发布前检查
- [ ] 是否进行了全项目敏感数据扫描？
- [ ] 所有测试用例是否通过？
- [ ] 文档示例是否已经脱敏？
- [ ] 配置文件是否使用示例数据？

#### 脱敏完成验证
- [ ] 使用正则表达式扫描无残留敏感数据
- [ ] 所有测试用例正常通过
- [ ] 功能演示使用通用数据
- [ ] 文档和注释已同步更新

### 8. 脱敏最佳实践

#### 预防性措施
```python
# ✅ 在代码中使用配置化的测试数据
TEST_DOMAINS = ["example1.net", "site1234.com", "test2222.xyz"]
TEST_VIDEO_IDS = ["TEST896", "DEMO001", "SAMPLE232"]

# ❌ 避免在代码中硬编码真实数据
REAL_DOMAIN = "btnets.net"  # 不要这样做
```

#### 文档脱敏
```markdown
# ✅ 使用通用示例
输入文件: example1.net_TEST-001.mp4
输出文件: TEST-001.mp4

# ❌ 避免真实示例
输入文件: btnets.net_FSDSS-896.mp4  # 不要这样做
```

#### 配置文件脱敏
```yaml
# ✅ 使用示例配置
rename_rules:
  - pattern: "example1.net_"
    replace: ""
  - pattern: "site1234.com@"
    replace: ""

# ❌ 避免真实配置
rename_rules:
  - pattern: "btnets.net_"  # 不要这样做
    replace: ""
```

---

## 📦 依赖管理规范

### 1. 依赖分类与管理策略
**规则**: 严格区分运行依赖、开发依赖和系统依赖，确保项目的可移植性和可维护性。

#### 依赖分类标准
```toml
# pyproject.toml 依赖分类示例
[project]
dependencies = [
    "python-dotenv",  # 环境变量管理
    "pyyaml",        # YAML配置文件解析
]

[project.optional-dependencies]
dev = [
    "pytest",        # 测试框架
    "pytest-cov",    # 测试覆盖率
    "pytest-mock",   # 测试模拟
    "pytest-xdist",  # 并行测试
]
```

#### 系统依赖管理
**规则**: 系统依赖必须在文档中明确说明安装方式，不能假设用户环境已安装。

**正确做法**:
```markdown
### 系统依赖
- **FFmpeg** (包含 ffprobe)：用于视频元数据提取
  - macOS: `brew install ffmpeg`
  - Ubuntu/Debian: `sudo apt-get install ffmpeg`
  - Windows: 下载并安装 FFmpeg 二进制文件
- **SQLite3**: 通常系统自带，Python 内置支持
```

### 2. 依赖分析与维护流程

#### 定期依赖审查
**规则**: 每次添加新功能后，必须审查和更新依赖配置。

**审查步骤**:
1. **代码扫描**: 使用工具扫描所有import语句
2. **分类整理**: 区分标准库、第三方库、系统依赖
3. **配置更新**: 更新pyproject.toml和文档
4. **测试验证**: 确保依赖配置正确

**工具使用示例**:
```bash
# 扫描Python导入
grep -r "^import\|^from.*import" --include="*.py" .

# 检查第三方库使用
grep -r "import \(pytest\|yaml\|dotenv\)" --include="*.py" .
```

### 3. 依赖版本管理

#### 版本固定策略
**规则**: 生产依赖使用兼容性版本范围，开发依赖可以更宽松。

```toml
# ✅ 正确的版本管理
dependencies = [
    "python-dotenv>=0.19.0,<2.0.0",  # 兼容性范围
    "pyyaml>=6.0,<7.0",               # 主版本锁定
]

# ❌ 避免的做法
dependencies = [
    "python-dotenv",     # 无版本约束，可能导致兼容性问题
    "pyyaml==6.0.1",     # 过度严格，阻碍安全更新
]
```

### 4. 依赖冲突解决

#### 冲突检测与解决
**规则**: 使用Poetry的依赖解析能力，避免手动管理复杂依赖关系。

**最佳实践**:
```bash
# 检查依赖冲突
poetry check

# 查看依赖树
poetry show --tree

# 更新依赖
poetry update

# 锁定依赖版本
poetry lock
```

---

## ⚙️ 配置管理规范

### 1. 配置文件层次结构
```
项目根目录/
├── .env                    # 环境变量配置
├── tools/
│   └── filename_formatter/
│       └── rename_rules.yaml  # 工具专用配置 ✅ 正确位置
└── config/                 # ❌ 避免创建额外配置目录
```

### 2. 环境变量管理
**规范**: 所有配置路径必须使用相对于项目根目录的路径

**示例**:
```bash
# ✅ 正确
RENAME_RULES_PATH=tools/filename_formatter/rename_rules.yaml

# ❌ 错误
RENAME_RULES_PATH=config/rename_rules.yaml  # 不存在的路径
```

### 3. 配置文件同步
**规则**: 避免在多个位置维护相同的配置文件

**问题案例**:
- 同时存在 `tools/filename_formatter/rename_rules.yaml` 和 `config/rename_rules.yaml`
- 导致配置不一致和维护困难

---

## 🧪 测试开发规范

### 1. 集成测试设计原则

#### 临时文件管理
```python
# ✅ 正确的测试清理策略
@pytest.fixture(autouse=True)
def setup_and_cleanup(self):
    """测试前清理，测试后保留供检查"""
    # 测试开始时清理上次的临时文件
    self._cleanup_temp_dir()
    
    yield
    
    # 测试完成后保留文件供人工检查
    print(f"临时文件保留在: {self.temp_dir_path}")
```

#### 测试数据管理
- 使用专门的 `tests/original_folder` 存放测试数据
- 每次测试从原始数据拷贝到临时目录
- 保持原始测试数据不变

### 2. 测试验证策略

#### 多层次验证
```python
def _validate_results(self):
    """多层次验证测试结果"""
    # 1. 文件数量验证
    assert len(actual_files) == len(expected_files)
    
    # 2. 文件名称验证
    assert actual_files == expected_files
    
    # 3. 特定重命名规则验证
    self._validate_specific_renames()
```

#### 错误处理测试
- 测试工具在无效输入下的行为
- 验证错误信息的准确性
- 确保程序优雅地处理异常情况

---

## 💻 代码风格规范

### 1. Python 代码规范

#### 函数命名
```python
# ✅ 清晰的函数命名
def _cleanup_temp_dir(self):
    """清理临时目录（只在测试开始时调用）"""

def _validate_specific_renames(self):
    """验证特定的重命名规则是否正确应用"""
```

#### 注释规范
```python
# ✅ 详细的注释说明
EXPECTED_RENAMES = {
    "btnets.net_TST-002.mp4": "TST-002.mp4",  # 移除 btnets.net_
    "TST-001.mp4": "TST-001.mp4",  # 已经是标准格式，不变
    "TST-003-FHD/TST-003-FHD.mp4": "TST-003-FHD/TST-003.mp4",  # 移除 -FHD
}
```

### 2. 测试代码组织

#### 测试类结构
```python
class TestFilenameFormatterIntegration:
    """集成测试类 - 清晰的职责分离"""
    
    # 常量定义
    TEMP_DIR_NAME = "integration_test_temp"
    ORIGINAL_FOLDER = "tests/original_folder"
    
    # 测试数据
    EXPECTED_RENAMES = {...}
    
    # 辅助方法
    def _cleanup_temp_dir(self): ...
    def _copy_original_folder(self): ...
    def _run_filename_formatter(self): ...
    def _validate_results(self): ...
    
    # 测试方法
    def test_complete_integration_workflow(self): ...
    def test_btnets_net_rule_integration(self): ...
```

---

## 📚 经验教训总结

### 1. 配置管理教训

#### 问题描述
在开发集成测试时，发现 `.env` 文件中配置的 `RENAME_RULES_PATH=config/rename_rules.yaml` 指向了不存在的文件。

#### 错误处理方式
为了让测试通过，直接创建了 `config` 目录和 `rename_rules.yaml` 文件。

#### 正确处理方式
应该立即停下来与用户确认：
1. 配置文件的正确位置
2. 是否需要修改 `.env` 配置
3. 项目的配置管理策略

#### 学到的教训
- **永远不要为了通过测试而随意创建文件**
- **遇到配置问题时必须先确认需求**
- **保持项目结构的一致性和简洁性**

### 2. 测试设计教训

#### 问题描述
最初的测试设计在每次测试后都删除临时文件，不便于人工检查结果。

#### 改进方案
- 只在测试开始时清理上次的临时文件
- 测试完成后保留文件供人工验证
- 添加友好的提示信息告知文件位置

#### 学到的教训
- **测试设计要考虑开发者的调试需求**
- **提供清晰的反馈信息**
- **平衡自动化和可观察性**

### 3. 功能重构教训（覆盖功能移除）

#### 问题描述
原始设计中包含了覆盖功能（`--overwrite`），允许覆盖现有文件，但这与工具的安全性原则相冲突。

#### 重构过程
1. **识别问题**: 覆盖功能与"安全重命名"原则冲突
2. **系统性移除**: 从CLI参数、核心逻辑、测试用例中完全移除
3. **测试验证**: 确保移除后所有功能正常
4. **文档更新**: 更新所有相关文档

#### 学到的教训
- **功能设计要与核心原则保持一致**
- **移除功能时要系统性地清理所有相关代码**
- **重构后必须进行全面的回归测试**
- **文档更新是重构的重要组成部分**

### 4. 默认行为优化教训（扁平化默认化）

#### 问题描述
原始设计中扁平化是可选功能（`--flatten`），但用户反馈认为应该是默认行为。

#### 优化过程
1. **需求分析**: 用户认为旧文件夹结构没有保留必要
2. **参数移除**: 移除`--flatten`参数，将扁平化设为默认
3. **测试调整**: 更新所有相关测试用例
4. **文档同步**: 更新CLI帮助和文档说明

#### 学到的教训
- **默认行为应该符合最常见的使用场景**
- **简化CLI参数可以提升用户体验**
- **功能变更需要同步更新测试和文档**
- **用户反馈是优化产品的重要依据**

### 5. 数据脱敏教训（2024年脱敏工作）

#### 问题描述
项目中存在大量敏感数据，包括真实域名（如 `btnets.net`）和敏感视频编号（如 `FSDSS896`、`ADN001`），这些数据分布在测试文件、配置文件、文档和示例代码中，影响了项目的安全性和可分享性。

#### 脱敏过程
1. **系统性扫描**: 使用正则表达式扫描所有文件中的敏感数据
2. **分类处理**: 区分测试代码、配置文件、文档、输出文件等不同类型
3. **批量替换**: 制定统一的替换规则进行批量处理
4. **功能验证**: 确保脱敏后所有测试通过，功能正常
5. **文档同步**: 更新所有相关文档和示例

#### 发现的问题
- **分布广泛**: 敏感数据散布在多个文件类型中，包括 `.py`、`.yaml`、`.md`、`.csv` 等
- **隐蔽性强**: 一些敏感数据隐藏在测试用例的断言中，不易发现
- **关联复杂**: 修改敏感数据后需要同步更新相关的测试期望值
- **遗漏风险**: 手动查找容易遗漏，需要系统性的扫描工具

#### 具体脱敏工作
```bash
# 域名脱敏
btnets.net → example1.net
kfa55.com → site1234.com  
xxx2222.xyz → test2222.xyz

# 视频编号脱敏
FSDSS896 → TEST896
ADN001 → DEMO001
DVMM232 → SAMPLE232

# 涉及文件类型
- 测试文件: test_*.py (75个测试用例)
- 配置文件: rename_rules.yaml (38条规则)
- 文档文件: *.md (示例和说明)
- 输出文件: *.csv (演示数据)
```

#### 学到的教训
- **预防优于治理**: 从项目开始就应该使用通用示例数据
- **系统性扫描**: 必须使用工具进行全面扫描，不能依赖人工查找
- **一致性原则**: 脱敏替换规则要保持一致，便于维护和理解
- **验证重要性**: 脱敏后必须进行完整的功能测试验证
- **文档同步**: 代码脱敏的同时必须同步更新所有相关文档
- **团队意识**: 需要建立团队的数据安全意识和脱敏规范

### 6. 依赖管理教训（2024年依赖维护工作）

#### 问题描述
项目使用Poetry管理依赖，但pyproject.toml中缺少重要的依赖包声明，包括：
- 测试相关依赖：`pytest-cov`、`pytest-mock`、`pytest-xdist`
- 系统依赖说明：`FFmpeg`、`SQLite3`
- 项目元数据不完整

#### 解决过程
1. **全面依赖分析**: 扫描所有Python文件的import语句
2. **分类整理**: 区分Python标准库、第三方包、系统依赖
3. **配置更新**: 系统性更新pyproject.toml配置
4. **文档同步**: 更新所有相关文档的依赖说明
5. **验证测试**: 确保依赖配置正确且测试通过

#### 发现的问题
- **隐性依赖**: 代码中使用了未在配置中声明的包
- **系统依赖缺失**: FFmpeg通过subprocess调用，但文档中未说明
- **测试依赖不全**: 缺少覆盖率和并行测试插件
- **元数据不完整**: 缺少项目描述、关键词、分类器等

#### 学到的教训
- **依赖声明必须完整**: 所有使用的第三方包都要在配置中声明
- **系统依赖需要文档化**: 外部工具依赖必须在安装文档中说明
- **定期依赖审查**: 每次功能更新后都要检查依赖变化
- **测试环境一致性**: 开发、测试、生产环境的依赖要保持一致
- **文档同步更新**: 依赖变更必须同步更新所有相关文档

---

## ⚠️ 反面教材与改进

### 1. 配置文件管理反面教材

#### ❌ 错误做法
```bash
# 发现 config/rename_rules.yaml 不存在
# 直接创建文件和目录
mkdir config
cp tools/filename_formatter/rename_rules.yaml config/
```

#### ✅ 正确做法
```bash
# 发现配置问题时
# 1. 停下来分析问题
# 2. 与用户确认正确做法
# 3. 修正 .env 配置
RENAME_RULES_PATH=tools/filename_formatter/rename_rules.yaml
```

### 2. 测试清理策略反面教材

#### ❌ 错误做法
```python
def teardown(self):
    """测试后立即删除所有临时文件"""
    shutil.rmtree(self.temp_dir_path)  # 无法人工检查结果
```

#### ✅ 正确做法
```python
def setup_and_cleanup(self):
    """智能的清理策略"""
    # 只清理上次的文件
    self._cleanup_temp_dir()
    yield
    # 保留本次结果供检查
    print(f"临时文件保留在: {self.temp_dir_path}")
```

### 3. 功能设计一致性反面教材

#### ❌ 错误做法
```python
# 同时提供覆盖和安全重命名功能
def rename_file(src, dst, overwrite=False):
    if overwrite or not dst.exists():
        src.rename(dst)  # 可能覆盖现有文件
```

#### ✅ 正确做法
```python
# 坚持安全重命名原则
def rename_file(src, dst, conflict_resolution="skip"):
    if dst.exists():
        if conflict_resolution == "skip":
            return "skipped: target exists"
        elif conflict_resolution == "rename":
            dst = generate_unique_name(dst)
    src.rename(dst)  # 绝不覆盖现有文件
```

### 4. 默认行为设计反面教材

#### ❌ 错误做法
```python
# 让用户为常见需求添加额外参数
parser.add_argument('--flatten', action='store_true', 
                   help='将文件移动到根目录')  # 大多数用户都需要这个功能
```

#### ✅ 正确做法
```python
# 将最常见的需求设为默认行为
# 扁平化默认启用，简化用户操作
flatten_output = True  # 默认行为
# 如果需要，可以添加 --no-flatten 选项
```

### 5. 数据脱敏反面教材

#### ❌ 错误做法
```python
# 在测试代码中直接使用真实敏感数据
def test_rename_rules(self):
    input_file = "btnets.net_FSDSS-896.mp4"  # 真实域名和敏感编号
    expected = "FSDSS-896.mp4"
    assert formatter.format_filename(input_file) == expected

# 在配置文件中使用真实数据
rename_rules:
  - pattern: "btnets.net_"  # 真实域名
    replace: ""
  - pattern: "FSDSS"        # 敏感前缀
    replace: "TEST"
```

#### ✅ 正确做法
```python
# 使用通用示例数据
def test_rename_rules(self):
    input_file = "example1.net_TEST-896.mp4"  # 通用域名和测试编号
    expected = "TEST-896.mp4"
    assert formatter.format_filename(input_file) == expected

# 在配置文件中使用示例数据
rename_rules:
  - pattern: "example1.net_"  # 示例域名
    replace: ""
  - pattern: "TEST"           # 通用前缀
    replace: "DEMO"
```

#### ❌ 错误的脱敏方式
```bash
# 手动逐个查找和替换，容易遗漏
grep "btnets.net" file1.py
sed -i 's/btnets.net/example1.net/' file1.py
# 忘记检查其他文件...

# 不验证脱敏后的功能
# 直接替换后不运行测试，导致功能异常
```

#### ✅ 正确的脱敏方式
```bash
# 系统性扫描所有文件
grep -r "btnets\.net" .
find . -type f \( -name "*.py" -o -name "*.yaml" -o -name "*.md" \) \
  -exec grep -l "btnets\.net" {} \;

# 批量替换并验证
find . -type f -name "*.py" -exec sed -i 's/btnets\.net/example1.net/g' {} +
pytest tests/ -v  # 验证功能正常
```

#### ❌ 错误的文档处理
```markdown
# 在文档中保留敏感示例
## 使用示例
输入: btnets.net_FSDSS-896.mp4
输出: FSDSS-896.mp4

# 在README中展示真实数据
支持的网站: btnets.net, kfa55.com
```

#### ✅ 正确的文档处理
```markdown
# 使用通用示例
## 使用示例
输入: example1.net_TEST-896.mp4
输出: TEST-896.mp4

# 在README中使用示例数据
支持的网站: example1.net, site1234.com
```

### 6. 依赖管理反面教材

#### ❌ 错误做法
```toml
# pyproject.toml 中依赖不完整
[project]
dependencies = [
    "python-dotenv",
    "pyyaml",
    # 缺少实际使用的测试依赖
]

# 没有说明系统依赖
# 代码中使用subprocess调用ffprobe，但未在文档中说明
```

#### ✅ 正确做法
```toml
# pyproject.toml 中完整的依赖声明
[project]
dependencies = [
    "python-dotenv>=0.19.0",
    "pyyaml>=6.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=7.0",
    "pytest-cov>=4.0",
    "pytest-mock>=3.10",
    "pytest-xdist>=3.0",
]

# 在README.md和HANDOVER.md中明确说明系统依赖
### 系统依赖
- FFmpeg (ffprobe): 用于视频元数据提取
- SQLite3: 数据库存储支持
```

#### ❌ 错误的依赖分析方式
```bash
# 仅凭记忆添加依赖，不进行系统性分析
# 忽略import语句扫描
# 不区分运行时依赖和开发依赖
```

#### ✅ 正确的依赖分析方式
```bash
# 系统性扫描所有import语句
grep -r "^import\|^from.*import" --include="*.py" .

# 分类整理依赖
# 1. Python标准库 (json, os, subprocess等)
# 2. 第三方Python包 (pytest, yaml等)  
# 3. 系统依赖 (ffmpeg, sqlite3等)

# 验证依赖配置
poetry check
poetry install --with dev
pytest -q  # 确保测试通过
```

---

## 🚀 最佳实践总结

### 1. 开发流程最佳实践
1. **需求确认**: 遇到不确定的需求时，立即与用户确认
2. **最小修改**: 优先使用现有文件和配置
3. **渐进开发**: 先实现核心功能，再完善细节
4. **及时验证**: 每个阶段都要验证功能正确性

### 2. 测试开发最佳实践
1. **数据隔离**: 使用专门的测试数据目录
2. **结果保留**: 保留测试结果供人工验证
3. **多层验证**: 从多个角度验证测试结果
4. **错误处理**: 测试异常情况和边界条件

### 3. 代码质量最佳实践
1. **清晰命名**: 函数和变量名要表达明确的意图
2. **详细注释**: 解释复杂逻辑和业务规则
3. **职责分离**: 每个函数只做一件事
4. **一致性**: 保持代码风格和项目结构的一致性

### 4. 功能重构最佳实践
1. **原则一致性**: 确保所有功能与核心设计原则保持一致
2. **系统性清理**: 移除功能时要清理所有相关代码、测试、文档
3. **用户体验优先**: 将最常用的功能设为默认行为
4. **安全第一**: 在便利性和安全性之间，优先选择安全性
5. **全面测试**: 重构后必须进行完整的回归测试
6. **文档同步**: 代码变更必须同步更新所有相关文档

### 5. 依赖管理最佳实践
1. **完整性原则**: 所有使用的依赖都必须在配置文件中明确声明
2. **分类管理**: 严格区分运行依赖、开发依赖、测试依赖和系统依赖
3. **版本策略**: 使用语义化版本范围，平衡稳定性和更新能力
4. **定期审查**: 每次功能更新后都要检查和更新依赖配置
5. **文档同步**: 依赖变更必须同步更新安装文档和交接文档
6. **环境一致**: 确保开发、测试、生产环境的依赖配置一致
7. **工具辅助**: 使用Poetry等工具进行依赖解析和冲突检测
8. **系统依赖**: 外部工具依赖必须在文档中说明安装方式

---

## 📝 检查清单

### 开发前检查
- [ ] 需求是否明确？
- [ ] 配置路径是否正确？
- [ ] 是否需要创建新文件？
- [ ] 项目结构是否合理？

### 开发中检查
- [ ] 是否遵循现有的代码风格？
- [ ] 是否使用了现有的工具和库？
- [ ] 是否添加了必要的注释？
- [ ] 是否考虑了错误处理？

### 开发后检查
- [ ] 功能是否正确实现？
- [ ] 测试是否全部通过？
- [ ] 是否有不必要的文件创建？
- [ ] 文档是否需要更新？

### 功能重构检查
- [ ] 重构是否与核心原则一致？
- [ ] 是否系统性地清理了所有相关代码？
- [ ] 是否更新了所有相关测试用例？
- [ ] 是否更新了CLI帮助和文档？
- [ ] 是否进行了完整的回归测试？
- [ ] 默认行为是否符合用户期望？

### 数据脱敏检查
- [ ] 是否扫描了所有文件中的敏感数据？
- [ ] 是否使用正则表达式进行系统性检查？
- [ ] 测试文件中是否使用通用示例数据？
- [ ] 配置文件中是否移除了真实域名和标识？
- [ ] 文档和示例中是否使用了脱敏数据？
- [ ] 脱敏后是否运行了完整的测试验证？
- [ ] 是否检查了输出文件和日志中的敏感信息？
- [ ] 是否建立了敏感词汇表和检查规范？

### 依赖管理检查
- [ ] 是否扫描了所有import语句？
- [ ] 是否区分了运行依赖和开发依赖？
- [ ] 是否在pyproject.toml中声明了所有第三方包？
- [ ] 是否在文档中说明了系统依赖的安装方式？
- [ ] 是否使用了合适的版本约束策略？
- [ ] 是否运行了poetry check验证配置？
- [ ] 是否更新了README.md和HANDOVER.md中的依赖说明？
- [ ] 是否验证了依赖配置后测试仍能通过？

---

## 📖 相关文档

### 文档体系说明
本项目包含两份核心开发文档，各有不同的定位和作用：

#### DEVELOPMENT_GUIDELINES.md (本文档)
- **定位**: 开发规范与经验教训
- **内容**: 具体的开发原则、规范、最佳实践和反面教材
- **受众**: 开发团队成员，用于日常开发指导
- **更新频率**: 随着项目经验积累持续更新

#### DEVELOPMENT_OUTLINE.md
- **定位**: 项目开发纲要
- **内容**: 项目概述、技术栈、架构设计、功能说明、扩展路线
- **受众**: 新成员了解项目、项目规划和决策
- **更新频率**: 项目重大变更时更新

### 文档使用建议
1. **新成员入门**: 先阅读 `DEVELOPMENT_OUTLINE.md` 了解项目全貌
2. **日常开发**: 参考 `DEVELOPMENT_GUIDELINES.md` 遵循开发规范
3. **问题解决**: 在 `DEVELOPMENT_GUIDELINES.md` 中查找相关经验教训
4. **项目规划**: 参考 `DEVELOPMENT_OUTLINE.md` 中的扩展路线和架构设计

### 文档维护原则
- 保持两份文档的独立性和互补性
- 避免内容重复，确保各自专注于不同层面
- 定期检查文档间的一致性和关联性
- 根据项目发展适时调整文档结构和内容

---

*本文档基于 filename_formatter 工具开发过程中的实际经验总结，包括集成测试开发、功能重构、数据脱敏等多个方面的经验教训，旨在为后续开发提供指导和参考。*